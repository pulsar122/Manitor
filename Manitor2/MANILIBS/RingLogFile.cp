/*	Logfile, realisiert als Ringbuffer.	Besonderheiten:	- Ob der Buffer bereits ist, muß vorher mit "ready" abgefragt werden,	  da auf Exceptions (im Konstruktor) verzichtet wurde.	  ACHTUNG: Die Methoden testen NICHT auf "ready"-Status. Allein der	  Destruktor berücksichtigt dies.	  Also: Keine Methode darf aufgerufen werden, wenn "ready" false liefert!	- Daten werden per "fill" zunächst im Buffer (ohne Dateizugriff!) geloggt.	  "fill" kann daher auch im Supervisormode (Interrupts) erfolgen,	  man muß jedoch die fill-Vorgänge selbst synchronisieren.	  "fill" ist also selbst nicht reentrant.	  Aber ein "fill" stört _nicht_ die "update"-Funktion (s.u.).	- Das tatsächliche Schreiben der Daten in die Datei erfolgt mit "update".	  Das ruft man an geeigneter Stelle in geeigneten Abständen (im Usermode) auf.	  Während die update-Funktion läuft, darf fill (aus Interrupts!)	  problemlos aufgerufen werden.*/#include <RingLogFile.h>#include <string.h>#include <stdlib.h>#include <gemdos.h>RingLogFile::RingLogFile(char *logfile, int32 buffer_size){	ready_flag = false;	filename = (char *)malloc(strlen(logfile) + 1);	bufsize = buffer_size;	buf = (char *)Malloc(bufsize);	bufsaveptr = buf;	bufsaverest = bufsize;	bufptr = buf;	bufrest = bufsize;	hnd = -1;		if (filename && buf) {		strcpy(filename, logfile);		int32 back = Fcreate(filename, 0);		if (back >= 0L) {			hnd = (int16)back;			ready_flag = true;		}	}}RingLogFile::~RingLogFile(){	if (ready_flag) {		update();	}	if (hnd >= 0) {		Fclose(hnd);	}	if (buf) {		Mfree(buf);	}	if (filename) {		free(filename);	}}#define OVERFLOW "\r\n\r\n+++ OVERFLOW! +++\r\n\r\n "#define OVERSIZE ((long)sizeof(OVERFLOW) - 2)// Leerzeichen am Ende von OVERFLOW ist wichtig! (siehe overflow)// OVERSIZE ist die Länge von OVERFLOW ohne dieses Leerzeichen! (Und ohne 0-Byte)// spezielles fill für Overflow-Warnung// fill würde über noch zu speichernde Daten (bufsaveptr) drüberschreiben!// bufsaveptr muß > bufptr sein, Ausnahme: bufsaveptr == bufvoid RingLogFile::overflow(){	int32 offset = bufsaveptr - bufptr;	if (offset < 0L)			// Kommt nur bei bufsaveptr == buf vor		offset += bufsize;	if (offset > OVERSIZE) {	// Overflow-Meldung paßt noch "rein"		memcpy(bufptr, OVERFLOW, OVERSIZE);		bufrest -= OVERSIZE;		bufptr += OVERSIZE;	} else {		char *neuptr = bufsaveptr - OVERSIZE - 1;	// Hier müßte OVERFLOW-Text anfangen		offset = buf - neuptr;		if (offset > 0L) {		// Steht links raus?			memcpy(buf + bufsize - offset, OVERFLOW, (size_t)offset);			if (OVERSIZE - offset > 0L) {				memcpy(buf, OVERFLOW + offset, (size_t)(OVERSIZE - offset));			}		} else {			memcpy(neuptr, OVERFLOW, OVERSIZE);		}		bufptr = neuptr + OVERSIZE;		if (bufptr < buf) {			bufptr += bufsize;		}		bufrest = bufsize - (bufptr - buf);	}}void RingLogFile::fill(const char *data, int32 len){	if (len) {		while (len >= bufrest) {			if (bufsaveptr > bufptr || bufsaveptr == buf) {	// Füllzeiger darf Schreibzeiger nie einholen!				overflow();				return;			}			memcpy(bufptr, data, (size_t)bufrest);			data += bufrest;			len -= bufrest;			bufptr = buf;			bufrest = bufsize;		}		if (len) {			char *neuptr = bufptr + len;			if (bufsaveptr > bufptr && bufsaveptr <= neuptr) { // Füllzeiger darf Schreibzeiger nie einholen!				overflow();				return;			}			memcpy(bufptr, data, (size_t)len);			bufrest -= len;			bufptr = neuptr;		}	}}void RingLogFile::fill_string(const char *str){	fill(str, (int32)strlen(str));}void RingLogFile::fill_crlf(){	fill("\r\n", 2);}void RingLogFile::update(){	char *local_bufptr = bufptr;	// bufptr kann jederzeit geändert werden	if (bufsaveptr > local_bufptr) {		Fwrite(hnd, bufsaverest, bufsaveptr);		bufsaveptr = buf;		bufsaverest = bufsize;	}	int32 len = local_bufptr - bufsaveptr;	if (len > 0L) {		Fwrite(hnd, len, bufsaveptr);		bufsaverest -= len;		bufsaveptr += len;	}}