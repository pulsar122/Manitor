/*----------------------------------------------------------------------------------------	SysInfo.cp, class for system information	3.6.2000 by Manfred Lippert, mani@mani.de	last change: 23.8.2001----------------------------------------------------------------------------------------*/#include <SysInfo.h>#include <Cookie.h>#if TARGET_TOS#include <TOS_Files.h>#include <string.h>#endifSysInfo sysinfo;				// global SysInfo object#if TARGET_TOS/* Return:	0	no MagiC				-1	MagiC but no AES (AUTO-folder)				0x0a0b	Version a.b	if crdate != 0L: 0xjjjjmmtt*/static int16 get_MagiC_ver(uint32 *crdate) {	MAGX_COOKIE *cook;	AESVARS *av;	if (!get_cookie('MagX', (int32 *)&cook))		return(0);	av = cook->aesvars;	if	(!av)		return(-1);	if	(crdate) {		*crdate = (uint32)(av->date) << 16;						// jjjj0000		*crdate |= (uint32)(av->date) >> 24;					// jjjj00tt		*crdate |= ((uint32)(av->date) >> 8) & 0xff00UL;	// jjjjmmtt	}	return(av->version);}static void get_obfix_raster(int16 *breite,int16 *hoehe, int16 *global) {    OBJECT tree[1]={-1,-1,-1,G_BOX,NONE,NORMAL,0x00000000l,0,0,1,1};    rsrc_obfix(tree, 0, global);    *breite=tree[0].ob_width;    *hoehe=tree[0].ob_height;}/*#define TRENNER '\\'// Dateinamen/Pfad-LŠngen (ohne 0-Bytes)#define MAXPATH 256#define MAXDAT 63#define MAXPATHDAT (MAXPATH + MAXDAT)// mit 0-Bytes:#define MAXPATH0 (MAXPATH+1)#define MAXDAT0 (MAXDAT+1)#define MAXPATHDAT0 (MAXPATHDAT+1)*/#if SYSINFO_AESint16 SysInfo::appl_xgetinfo(int16 type, int16 *out1, int16 *out2, int16 *out3, int16 *out4, int16 *global) {	if ((global[0] == 0x399 && this->magic)            || (global[0] == 0x400 && type < 4)            || (global[0] > 0x400)            || (appl_find ("?AGI", global) >= 0))	{		return appl_getinfo(type, out1, out2, out3, out4, global);	}	return 0;}#endifErr SysInfo::init() {#if SYSINFO_MISC	uint16 version = (uint16)Sversion();	this->mint = get_cookie('MiNT', 0L);	this->gemdosversion = (int16)(((version << 8) & 0xFF00) | ((version >> 8) & 0x00FF));	this->magic_ver = get_MagiC_ver(&this->magic_date);	this->magic = (this->magic_ver > 0);	this->magicmac = get_cookie('MgMc', 0L);	this->magicpc = get_cookie('MgPC', 0L);	this->Mxalloc = ((::Mxalloc(-1, 0)) >= (void *)0);	if (this->magic_ver < 0x200 && !this->mint) {		this->Mxmask = 0x3;	} else {		this->Mxmask = 0xFFFF;	}	{		char path[MAXPATH0];		TOS_current_path(path);		startpath.TOS_init_path(path);	}#endif	// SYSINFO_MISC#if SYSINFO_VDI	{		NVDI_COOKIE *cook;		this->nvdi = get_cookie('NVDI', (int32 *)&cook);		if (this->nvdi) {			this->nvdi_cookie = *cook;		} else {			this->nvdi_cookie.version = 0;			this->nvdi_cookie.date = 0L;		}	}	this->gdos = (vq_gdos() != 0);	if (this->gdos) {		this->speedo = (get_cookie('FSMC', 0L) != 0);	} else {		this->speedo = FALSE;	}	this->EdDI = get_cookie('EdDI', (int32 *)&(this->EdDI_dispatch));	if (this->EdDI) {		this->EdDI_version = this->EdDI_dispatch(0);	} else {		this->EdDI_version = 0;	}#endif	// SYSINFO_VDI#if SYSINFO_AES	int16 *global = main_thread->TOS_get_global();	int16 out1, out2, out3, out4;	this->aes_handle = graf_handle(&this->wchar, &this->hchar, &out3, &out4, global);	get_obfix_raster(&this->wobfix, &this->hobfix, global);	if (appl_xgetinfo(11, &out1, &out2, &out3, &out4, global)) {		this->wfbevent = (boolean)(out1 & 0x20);		this->wfowner = (boolean)(out1 & 0x10);		this->wfbottom = (boolean)(out1 & 0x40);		this->wfhotclose = (boolean)(out1 & 0x8);		this->newdeskget = (boolean)(out1 & 0x2);	} else {		this->wfbevent = FALSE;		this->wfowner = FALSE;		this->wfbottom = FALSE;		this->wfhotclose = FALSE;		this->newdeskget = FALSE;	}	if (appl_xgetinfo(12, &out1, &out2, &out3, &out4, global)) {		this->ap_term = (boolean)(out1 & 0x08);		this->wficonify = (boolean)(out1 & 0x80);		this->wficonipos = (boolean)(out3 != 0);	} else {		this->ap_term = FALSE;		this->wficonify = FALSE;		this->wficonipos = FALSE;	}	this->edscroll = (this->magic && this->magic_date >= 0x19950829L);	if (appl_xgetinfo(0, &out1, &out2, &out3, &out4, global)) {		this->aes_font = out2;		this->aes_height = out1;	} else {		this->aes_font = 1;		this->aes_height = (this->hchar < 16) ? 9 : 10;	}	if (appl_xgetinfo(1, &out1, &out2, &out3, &out4, global)) {		this->aes_font_small = out2;		this->aes_height_small = out1;	} else {		this->aes_font_small = 1;		this->aes_height_small = 4;	}	if (appl_xgetinfo(13, &out1, &out2, &out3, &out4, global)) {		this->gshortcut = (boolean)(out4 & 0x8);	/* Bit 3: G_SHORTCUT? */		this->obj3d = (boolean)(out1 != 0);		if (this->obj3d && out2) {			/* 3D-Objekte und objc_sysvar vorhanden? */			objc_sysvar(0, AD3DVALUE, 0,0, &this->breiter3d, &this->hoeher3d, global);		}	} else {		this->gshortcut = FALSE;		this->obj3d = FALSE;		this->breiter3d = 0;		this->hoeher3d = 0;	}	{		char cmd[MAXPATH0] = "";		char tail[256];		if (shel_read(cmd, tail, global) != 0 && cmd[0] && TOS_cut_last_dir(cmd, 0L)) {			startpath.TOS_init_path(cmd);		}	}	GRECT16 tos_rect;	wind_get_rect(0, WF_WORKXYWH, &tos_rect, global);	this->desk.TOS_set(&tos_rect);/*	if (!appl_xgetinfo(7, &out1, &out2, &out3, &out4, global) || (out1 & 0x3) != 0x3) {		alert(1, "[1][WDIALOG nicht installiert|oder zu alt!][Oops!]");		return ERR_ERR;	}*/	this->multitasking = (global[1] != 1);	if (appl_xgetinfo(10, &out1, &out2, &out3, &out4, global)) {		this->doex_bits = out1;		this->accstart = (boolean)((out1 & 0xFF) >= 3);		this->parallelstart = (boolean)(out2 == 0);	} else {		this->doex_bits = 0;		this->accstart = FALSE;		this->parallelstart = this->multitasking;	}	this->parallelstart = (this->parallelstart || this->magic);	/* Sicherheitshalber */	if (this->magic_ver >= 0x300) {		this->accstart = TRUE;		/* MagiC liefert's falsch! */	}	if (appl_xgetinfo(4, &out1, &out2, &out3, &out4, global)) {		this->mint2aesid = (boolean)out2;		this->applsearch = (boolean)out3;	} else {		this->mint2aesid = FALSE;		this->applsearch = FALSE;	}	if (appl_xgetinfo(2, &out1, &out2, &out3, &out4, global)) {		this->coloricons = (boolean)out3;	} else {		this->coloricons = global[0] >= 0x330 && !this->magic;	}#endif	// SYSINFO_AES	return OK;}void SysInfo::dispose() {	startpath.dispose();}#endif	// TARGET_TOS#if TARGET_MACOSErr SysInfo::init() {	int32 response;	OSErr oserr;	os_version = 0;	Gestalt(gestaltSystemVersion, &os_version);	carbon_version = 0;	Gestalt(gestaltCarbonVersion, &carbon_version);	oserr = Gestalt(gestaltFSAttr, &response);	has_HFSPlus_APIs = (oserr == noErr && (response & (((uint32)0x1) << gestaltHasHFSPlusAPIs)) != 0);	has_carbon_events = (carbon_version >= 0x110);	oserr = Gestalt(gestaltMenuMgrAttr, &response);	has_aqua_menu_layout = (oserr == noErr && (response & gestaltMenuMgrAquaLayoutMask) != 0);	mp_support = MPLibraryIsLoaded();	if (carbon_version < 0x125) {		// Out of TechNote 2006 (MP-Safe Routines):		//		// Due to a problem in earlier versions of the CarbonLib extension, many of the routines		// that were are documented as MP-safe in Mac OS 9.0 and above are not MP-safe if any version		// of CarbonLib prior to version 1.2.5 is installed!		//		// IMPORTANT:		// If your application uses the Multiprocessing Library routines, then you should ensure		// CarbonLib 1.2.5 (or later) is installed.		mp_support = FALSE;	}	return OK;}void SysInfo::dispose() {}#endif	// TARGET_MACOS