#include "Manitor.h"#include "ReturnTrace.h"#include <xbios.h>#include <Semaphore.h>#include <stdlib.h>#include <string.h>ReturnInfoTable return_info_table = {{0, MAX_RETURNS, sizeof(ReturnInfo)}};BiosReturnInfoTable biosreturn_info_table = {{0, MAX_LAYER_RETURNS, sizeof(BiosReturnInfo)}};XbiosReturnInfoTable xbiosreturn_info_table = {{0, MAX_LAYER_RETURNS, sizeof(XbiosReturnInfo)}};GemdosReturnInfoTable gemdosreturn_info_table = {{0, MAX_LAYER_RETURNS, sizeof(GemdosReturnInfo)}};VDIReturnInfoTable vdireturn_info_table = {{0, MAX_LAYER_RETURNS, sizeof(VDIReturnInfo)}};AESReturnInfoTable aesreturn_info_table = {{0, MAX_LAYER_RETURNS, sizeof(AESReturnInfo)}};void *get_next_table_entry(ReturnTable *table) {	void *info = 0L;	if (table->anz < table->maxanz) {		info = (void *)(((int8 *)(table + 1)) + table->entrysize * table->anz);	}	table->anz++;	return info;}static int16 return_semaphore;void *begin_layer_table_entry(ReturnTable *layertable, int16 layer, int16 is_super) {	if (!is_super) {		do {		} while (!get_Semaphore(&return_semaphore));	}	void *entry = 0L;	ReturnInfo *ret = (ReturnInfo *)get_next_table_entry(&return_info_table.table);	if (ret) {		entry = get_next_table_entry(layertable);		ret->layer = layer;		ret->info = entry;		ret->time = my_200Hz;		ret->bp = *p_run;		ret->is_super = is_super;	}	return entry;}void end_layer_table_entry(int16 is_super){	if (!is_super) {		return_semaphore = 0;	}}void Output_Prefix(int32 timer, BASPAG *pb){	static char nr[12];	ltoa(timer - my_200Hz_begin, nr, 10);	log->fill_string(nr);	log->fill_string(": [");	char *process_name = 0L;	char *env = pb->p_env;	if ((int32)env > 0L) {		while (*env) {			if (strncmp(env, "_PNAM=", 6) == 0) {				process_name = (env + 6);		// _PNAM gefunden, Proze§name ermittelt				break;			}			env += strlen(env) + 1;		}	}	int16 width = 16;	if (process_name) {		log->fill_string(process_name);		width -= (int16)strlen(process_name);	} else {		log->fill_string("BP: $");		ltoa((int32)pb, nr, 16);		log->fill_string(nr);		width -= (int16)strlen(nr) + 5;	}	log->fill_string("] ");	if (width > 0) {		log->fill("                ", width);	}}void Output_Returns()	// Aufruf aus Calls-Traces, also nur Super-Mode!{	static char nr[12];	if (!return_semaphore) {	// Es wird gerade nix eingetragen		int16 lost = return_info_table.table.anz - return_info_table.table.maxanz;		if (lost > 0) {			return_info_table.table.anz = return_info_table.table.maxanz;		}		ReturnInfo *ret = &return_info_table.entries[0];		for(int i = 0; i < return_info_table.table.anz; i++, ret++) {			Output_Prefix(ret->time, ret->bp);			log->fill(ret->is_super ? "S" : " ", 1);			if (!ret->info) {				switch(ret->layer) {				case TRAPPER_BIOS:					log->fill_string(">Lost Bios Return\r\n");					break;				case TRAPPER_XBIOS:					log->fill_string(">Lost Xbios Return\r\n");					break;				case TRAPPER_GEMDOS:					log->fill_string(">Lost Gemdos Return\r\n");					break;				case TRAPPER_VDI:					log->fill_string(">Lost VDI Return\r\n");					break;				case TRAPPER_AES:					log->fill_string(">Lost AES Return\r\n");					break;				}			} else {				switch(ret->layer) {				case TRAPPER_BIOS:					Output_BiosReturn((BiosReturnInfo *)ret->info);					break;				case TRAPPER_XBIOS:					Output_XbiosReturn((XbiosReturnInfo *)ret->info);					break;				case TRAPPER_GEMDOS:					Output_GemdosReturn((GemdosReturnInfo *)ret->info);					break;				case TRAPPER_VDI:					Output_VDIReturn((VDIReturnInfo *)ret->info);					break;				case TRAPPER_AES:					Output_AESReturn((AESReturnInfo *)ret->info);					break;				}			}		}		if (lost > 0) {			itoa(lost, nr, 10);			log->fill_string(">Lost ");			log->fill_string(nr);			log->fill_string(" unknown Returns\r\n");		}		return_info_table.table.anz = 0;		biosreturn_info_table.table.anz = 0;		xbiosreturn_info_table.table.anz = 0;		gemdosreturn_info_table.table.anz = 0;		vdireturn_info_table.table.anz = 0;		aesreturn_info_table.table.anz = 0;	}}