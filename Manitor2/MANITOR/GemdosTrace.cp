#include "Manitor.h"#include "ReturnTrace.h"#include "GemdosTrace.h"#include <xbios.h>#include <stdlib.h>#include <string.h>void Output_GemdosReturn(GemdosReturnInfo *info){	static char nr[12];	itoa(info->opcode, nr, 10);	log->fill_string(">Gemdos#");	log->fill_string(nr);	log->fill(" => ", 4);	ltoa(info->ret, nr, 10);	log->fill_string(nr);	log->fill_crlf();#if 0if (info->opcode == 63) {	// Fread	int16 handle = info->para[0];	int32 count = *(int32 *)&info->para[1];	char *buf = *(char **)&info->para[3];	log->fill_string("Fread: Handle: ");	itoa(handle, nr, 10);	log->fill_string(nr);	log->fill_crlf();	log->fill(">>", 2);	log->fill(buf, count);	log->fill("<<", 2);	log->fill_crlf();}#endif}int32 CDECL GemdosCallTrace(int16 *para, int16 *call_original, int16 super_called){#pragma unused(call_original)	static char nr[8];	ENTER_CALLBACK();// Anstehende Return-Ausgaben tŠtigen:	Output_Returns();// Jetzt diesen Call ausgeben:	Output_Prefix(my_200Hz, *p_run);	log->fill(super_called ? "S" : " ", 1);	log->fill_string(" Gemdos#");	itoa(*para, nr, 10);	log->fill_string(nr);	log->fill_crlf();#if 0if (*para == 64 && *p_run != _BasPag) {		// Fwrite	log->fill_string("Fwrite: Handle: ");	itoa(para[1], nr, 10);	log->fill_string(nr);	log->fill_crlf();	log->fill(">>", 2);	log->fill(*(char **)&para[4], *(int32 *)&para[2]);	log->fill("<<", 2);	log->fill_crlf();}#endif	if (update_immediate && *para != 64) {	// sofort rausschreiben? (Aber nicht bei Fwrite - sonst Endlos-Rekursion!!)		log->update();	}	EXIT_CALLBACK();	return E_OK;}int32 CDECL GemdosReturnTrace(int32 ret, int16 *para, int16 is_super){	ENTER_CALLBACK();	GemdosReturnInfo *gret = (GemdosReturnInfo *)begin_layer_table_entry(&gemdosreturn_info_table.table, TRAPPER_GEMDOS, is_super);	if (gret) {		gret->opcode = *para++;		gret->ret = ret;		int32 *src = (int32 *)para;		int32 *dst = (int32 *)gret->para;#if GEMDOSPARA_MAX_LONGS != 6#error Anpassen!!!#endif		*dst++ = *src++;		*dst++ = *src++;		*dst++ = *src++;		*dst++ = *src++;		*dst++ = *src++;		*dst = *src;	}	end_layer_table_entry(is_super);	EXIT_CALLBACK();	return ret;}